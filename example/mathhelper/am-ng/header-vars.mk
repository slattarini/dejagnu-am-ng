
# Makefiles generated by Automake-NG require GNU make >= 3.81.
# The .FEATURES special variable has been introduced in that make
# version, so use it as a witness to determine whether the current
# make is good enough.
ifndef .FEATURES
  $(error Automake-NG based builds require GNU make 3.81 or later)
endif

VPATH = $(srcdir)

# Enhance performance by removing GNU make builtin rules that would be
# rather irrelevant (e.g., rules to automatically check out files from
# from RCS or SCCS repositories), or overridden by Automake (e.g., rules
# to compile C or C++ files).  For larger packages (like GNU coreutils),
# this can greatly speed up null or almost-null builds, up to even 50%!
MAKEFLAGS += --no-builtin-rules

# For when we need a do-nothing target.  Add an actual rule to it to avoid
# the annoying message "make[1]: Nothing to be done for .am/nil" from make.
.PHONY: .am/nil
.am/nil:
	@:

# Declare an error, without immediately terminating the execution (proper
# code will take care later of that).  This will allow us to diagnose more
# issues at once, rather than stopping at the first one.
am.error.seen :=
define am.error
$(warning $1)$(eval am.error.seen := yes)
endef

# Declare an error, and immediately terminate execution.
define am.fatal
$(if $1,$(call am.error,$1))$(error Some Automake-NG error occurred)
endef

#
# Sometimes, in our makefiles, we want to assign a default value to a
# variable that might not have been assigned yet.  One might think that
# using the GNU make assignment '?=' is enough:
#
#    VAR ?= DEFAULT-VALUE
#
# But alas, such a usage allows interferences from the environment; i.e.,
# if an environment variable named 'VAR' is defined to, say, BAD-VALUE,
# the construct above will result in the $(VAR) make variable being
# defined to BAD-VALUE, not to DEFAULT-VALUE.
#
# Use the 'am.vars.is-undef' function to avoid this situation.  It tells
# whether the given make variable is not "safely" defined, i.e., either
# undefined, or defined to a value that is inherited from the environment.
#
# With such a tool, we can safely declare default values for variables
# that avoids environmental interferences, as follow:
#
#     ifeq ($(call am.vars.is-undef,VAR),yes)
#       VAR = DEFAULT-VALUE
#     endif
#
define am.vars.is-undef
$(if $(filter undefined environment,$(origin $(strip $1))),yes)
endef

# Some problematic characters (especially when used in arguments
# to make functions, or for syntax highlighting).
am.chars.bslash := \\
am.chars.comma := ,
am.chars.dollar := $$
am.chars.hash := \#
am.chars.lparen := (
am.chars.rparen := )
am.chars.bquote := `
am.chars.dquote := "
am.chars.squote := '
# "` # Fix font-lock.

# An empty string.  It can be very useful to "fool" the make parser w.r.t.
# whitespace handling, and allow us to obtain tricky semantics.  See the
# definition of $(am.chars.newline) just below for a significant example.
am.chars.empty :=

# A single whitespace.
am.chars.space := $(am.chars.empty) $(am.chars.empty)

# A single tabulation character.
am.chars.tab := $(am.chars.empty)	$(am.chars.empty)

# A literal newline character, that does not get stripped if used
# at the end of the expansion of another macro.
define am.chars.newline

$(am.chars.empty)
endef

# Neutralize unwarranted environment settings that might interfere with
# our Makefiles.
ifeq ($(call am.vars.is-undef,SUBDIRS),yes)
  SUBDIRS :=
endif
ifeq ($(call am.vars.is-undef,EXEEXT),yes)
  EXEEXT :=
endif

# CDPATH is only useful in interactive usage, and should never be exported
# in the environment; doing so could cause our recipes and scripts to chdir
# to unexpected places, causing all sort of hard to reproduce mayhem.
# Still, but some people nonetheless export CDPATH (or did so in the past),
# so to be extra safe we have to neutralize it.
unexport CDPATH

# Be verbose by default.  Yes, we really want $(V) to be overridable
# from the environment, both for simplicity and for consistency with
# mainline Automake.
# FIXME: maybe normalize/sanitize $(V)?
V ?= 0

# In a recipe, ensure the given directory exists, creating it if
# necessary; but tries to do so avoiding useless forks, stats, and
# extra recipe text (the latter is useful when doing "make V=1").
# If the target has no directory component, or if the parent
# directory of the target already exists, we have nothing to do, so
# try to optimize for those cases -- especially because, for our
# usage patterns, one of them should always be true in non-VPATH
# builds.
am.cmd.ensure-dir-exists = \
  $(if $(filter .,$1),:,$(if $(wildcard $1/),:,$(MKDIR_P) $1))

# Ensure the directory containing the target of the current recipe
# exists, by creating it if necessary.
am.cmd.ensure-target-dir-exists = $(call am.cmd.ensure-dir-exists,$(@D))

# The 'all' target must be the default one, independently from the
# position it is declared in the output Makefile.
.DEFAULT_GOAL := all

# Emulate VPATH rewrites.  This uses only GNU make primitives, which
# allows us to avoid extra forks.
am.vpath.rewrite = \
  $(firstword $(wildcard $(strip $(1))) $(srcdir)/$(strip $(1)))

# make this overridable from the environment, for better compatibility
# with mainline Automake.
DESTDIR ?=

# Tell whether make is running in "dry mode".  It is either 'true' or
# 'false', so that it can be easily used in shell code as well as in
# GNU make conditionals.
# If we run "make TESTS='snooze nap'", GNU make will export MAKEFLAGS to
# "TESTS=foo\ nap", so that the builtins operating on word-split lists
# would see a "make flag" equal to "nap" when analyzing $(MAKEFLAGS), and
# would wrongly misinterpret that as and indication that make is running
# in dry mode.  This has already happened in practice.  So we need the
# hack with $(subst \ , ...).
am.make.dry-run := \
  $(strip $(if $(strip \
    $(foreach v, $(subst \ ,,$(strip $(MAKEFLAGS))), \
      $(if $(or $(findstring =,$v),$(filter --%,$v)),, \
        $(findstring n,$v)))), \
    true, false))

am.util.strip-first-word = $(wordlist 2,$(words $(1)),$(1))
am.util.strip-last-word  = $(wordlist 2,$(words $(1)),dummy $(1))

# Remove repeated elements from the given list (without reordering),
# and return the reduced list.
am.util.uniq = $(strip \
  $(if $(strip $(1)), \
    $(call $0, \
      $(call am.util.strip-last-word, $(1))) \
      $(if $(filter $(lastword $(1)), \
                    $(call am.util.strip-last-word, $(1))), \
           $(am.chars.empty), \
           $(lastword $(1)))))

am.util.tolower = $(subst Z,z,$(subst Y,y,$(subst X,x,$(subst W,w,$(subst V,v,$(subst U,u,$(subst T,t,$(subst S,s,$(subst R,r,$(subst Q,q,$(subst P,p,$(subst O,o,$(subst N,n,$(subst M,m,$(subst L,l,$(subst K,k,$(subst J,j,$(subst I,i,$(subst H,h,$(subst G,g,$(subst F,f,$(subst E,e,$(subst D,d,$(subst C,c,$(subst B,b,$(subst A,a,$1))))))))))))))))))))))))))

am.util.toupper = $(subst z,Z,$(subst y,Y,$(subst x,X,$(subst w,W,$(subst v,V,$(subst u,U,$(subst t,T,$(subst s,S,$(subst r,R,$(subst q,Q,$(subst p,P,$(subst o,O,$(subst n,N,$(subst m,M,$(subst l,L,$(subst k,K,$(subst j,J,$(subst i,I,$(subst h,H,$(subst g,G,$(subst f,F,$(subst e,E,$(subst d,D,$(subst c,C,$(subst b,B,$(subst a,A,$1))))))))))))))))))))))))))

# Canonicalize the given filename.  See also the &canonicalize function
# in the automake script.

am.util.canon = $(strip \
  $(subst ~,_,\
  $(subst },_,\
  $(subst |,_,\
  $(subst {,_,\
  $(subst $(am.chars.bquote),_,\
  $(subst ^,_,\
  $(subst $(am.chars.bslash),_,\
  $(subst [,_,\
  $(subst ],_,\
  $(subst ?,_,\
  $(subst >,_,\
  $(subst =,_,\
  $(subst <,_,\
  $(subst ;,_,\
  $(subst :,_,\
  $(subst /,_,\
  $(subst .,_,\
  $(subst -,_,\
  $(subst $(am.chars.comma),_,\
  $(subst +,_,\
  $(subst *,_,\
  $(subst $(am.chars.lparen),_,\
  $(subst $(am.chars.rparen),_,\
  $(subst $(am.chars.squote),_,\
  $(subst &,_,\
  $(subst %,_,\
  $(subst $(am.chars.dollar),_,\
  $(subst $(am.chars.hash),_,\
  $(subst $(am.chars.dquote),_,\
  $(subst !,_,$1)))))))))))))))))))))))))))))))


# Simple memoization for recursive make variables.  It is useful for
# situations where immediate variables can't be used (due, say, to
# ordering issues with the assignments of the referenced variables),
# but where the value of the lazy variable is costly to calculate
# (e.g., a $(shell ...) call with a non-trivial command line), so that
# we can't afford to re-calculate it over and over every time the
# variable gets expanded.  Example of usage:
#
#   var1 = $(am.memoize,var1,$(shell EXPENSIVE-COMMAND-LINE))
#   var2 = $(am.memoize,var2,$(sort VERY-LONG-LIST))
#
# This API and implementation seems to work around a bug in GNU make
# (present up to and including version 3.82) which caused our first
# implementation attempts to fail:
#
#   <http://lists.gnu.org/archive/html/bug-make/2012-05/msg00013.html>
#   <https://savannah.gnu.org/patch/?7534>
#
# So please don't change this without a very good reason.
#
am.memoize = $(or $(am.memoize.value/$1),$(strip \
  $(eval am.memoize.value/$1 := $$2))$(am.memoize.value/$1))

# $(call am.util.strip-suffixes, SUFFIXES, LIST)
# ----------------------------------------------
# Strip any of the SUFFIXES from each of the entries of LIST.  Even if an
# entry of LIST terminates with several suffixes, only one is stripped:
# the first one that matches.
am.hack.private-suffix = .,;&!@
am.util.strip-suffixes = $(strip \
  $(if \
    $(strip $1), \
      $(patsubst %$(am.hack.private-suffix),%, \
        $(call $0, \
          $(call am.util.strip-first-word,$1), \
          $(patsubst %$(firstword $1),%$(am.hack.private-suffix),$2))), \
    $2))

# Now, some helper functions and variables to help in recipes that could
# exceed the command line length limit.

# And in the Information Age, we somehow managed to revert to abacus-like
# counting.  Yay for us :-)
am.max-cmdline-args := xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

# FIXME! The above accounts for max forty arguments; this is basically
# arbitrary.  In the long term, defining that after a configure-time test
# on the command-line length limits, or at least on a system-by-system
# basis, might be better.  But don't make the new limit too big (even if
# the system would allow it), or our implementation will likely suffer in
# performance and in memory consumption.

# $(call am.xargs-map,FUNCTION,LIST,[EXTRA-ARGS..])
# -------------------------------------------------
# Map the function $1 on the whitespace-separated list $2, ensuring that
# each call of $1 has at most 40 entries from that list at once.  If
# further arguments are given (up to $9), they are passed to each $1
# invocation.
# This implementation is hacky, but the more elegant or "naive" ones
# (based on recursion) proved to be ludicrously memory-hungry with
# huge lists.
# A drawback of this implementation is that am.xargs-map cannot be
# recursively invoked, but that shouldn't matter for our use cases.
# The extra $(strip) calls are only to allow clearer formatting.
define am.xargs-map
$(if $2,$(strip \
  )$(eval $0.partial-args :=)$(strip \
  )$(eval $0.counter :=)$(strip \
  )$(foreach i,$2,$(strip \
    )$(eval $0.counter := $$($0.counter)x)$(strip \
    )$(eval $0.partial-args += $$i)$(strip \
    )$(if $(filter $(am.max-cmdline-args),$($0.counter)),$(strip \
      )$(call $1,$(strip $($0.partial-args)),$3,$4,$5,$6,$7,$8,$9)$(strip \
      )$(eval $0.partial-args :=)$(strip \
      )$(eval $0.counter :=)))$(strip \
  )$(if $($0.counter),$(call $1,$(strip \
                        $($0.partial-args)),$3,$4,$5,$6,$7,$8,$9)))
endef

# Used only by the 'am.clean-cmd.*' functions below.  Do not use in
# other places.
am.hack.rm-f = $(if $(strip $1),rm -f $(strip $1)$(am.chars.newline))
am.hack.rm-rf = $(if $(strip $1),rm -rf $(strip $1)$(am.chars.newline))

# Needed to ensure the invocations of "rm -f" and "rm -rf" in our cleaning
# rules are not given too many arguments, which might cause command line
# length limits to be exceeded.  These are only meant to be used in a
# "sub-recipe" by their own; e.g.,
#
#    # This is ok.
#    clean-x:
#        @echo "Cleaning X Files"
#        @$(call am.clean-cmd.f,$(X_FILES))
#
#    # This is *wrong*.
#    clean-x:
#        @echo "Cleaning X Files" \
#          && $(call am.clean-cmd.f,$(X_FILES))
#
am.clean-cmd.f = $(call am.xargs-map,am.hack.rm-f,$1)
am.clean-cmd.d = $(call am.xargs-map,am.hack.rm-rf,$1)

# Some derived variables that have been found to be useful.
# These have since long been documented in the Automake manual and used
# by many real-world packages, so they are now an established feature
# and should not be changed.
pkgdatadir = $(datadir)/$(PACKAGE)
pkgincludedir = $(includedir)/$(PACKAGE)
pkglibdir = $(libdir)/$(PACKAGE)
pkglibexecdir = $(libexecdir)/$(PACKAGE)

install_sh_DATA = $(install_sh) -c -m 644
install_sh_PROGRAM = $(install_sh) -c
install_sh_SCRIPT = $(install_sh) -c
INSTALL_HEADER = $(INSTALL_DATA)
transform = $(program_transform_name)

# These are defined like this to avoid introducing gratuitous
# incompatibilities with mainline Automake.
NORMAL_INSTALL = :
PRE_INSTALL = :
POST_INSTALL = :
NORMAL_UNINSTALL = :
PRE_UNINSTALL = :
POST_UNINSTALL = :

# Number of files to install concurrently.
am__install_max = 40
# Take a "$list" of nobase files, collect them, indexed by their
# srcdir-stripped dirnames.  For up to am__install_max files, output
# a line containing the dirname and the files, space-separated.
# The arbitrary limit helps avoid the quadratic scaling exhibited by
# string concatenation in most shells, and should avoid line length
# limitations, while still offering only negligible performance impact
# through spawning more install commands than absolutely needed.
am__nobase_list = \
  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`; \
  for p in $$list; do echo "$$p $$p"; done | \
  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
    if (++n[$$2] == $(am__install_max)) \
      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
    END { for (dir in files) print dir, files[dir] }'
# Collect up to 40 files per line from stdin.
am__base_list = \
  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'

# New function, backslash-escape whitespace in the given string.
define am.util.whitespace-escape
$(subst $(am.chars.space),\$(am.chars.space),$(subst $(am.chars.tab),\$(am.chars.tab),$1))
endef

# Determine whether the given file exists.  Since this function is
# expected to be used on paths referencing $(DESTDIR), it must be
# ready to cope with whitespaces and shell metacharacters.
# FIXME: here we assume that the shell found by Autoconf-generated
# configure supports "test -e"; that is not completely correct ATM, but
# future versions of Autoconf will reject non-POSIX shells, so we should
# be safe in the long term.
define am.util.file-exists
$(strip \
  $(if $(strip $(findstring *,$1) $(findstring ?,$1) \
               $(findstring [,$1) $(findstring ],$1)), \
    $(shell test -e '$(subst $(am.chars.squote),'\'',$1)' && echo yes), \
    $(if $(wildcard $(call am.util.whitespace-escape,$1)),yes)))
endef

# $(call am.uninst.cmd,DIR,FILES,[RM-OPTS])
# -----------------------------------------
# Uninstall the given files from the given directory, avoiding to hit
# command line length limits, and honoring $(DESTDIR).  If the given DIR
# is actually an empty name, or it it refers to a non-existing file, it
# is assumed nothing is to be removed.  The RM-OPTS (if present) are
# passed to the rm invocation removing the files (this ca be useful in
# case such files are actually directories (as happens with the HTML
# documentation), in which case rm should be passed the '-r' option.
# Similarly to the 'am.clean-cmd.f' above, this function is only meant
# to be used in a "sub-recipe" by its own.

define am.uninst.cmd.aux
$(if $(and $2,$1),$(if $(call am.util.file-exists,$(DESTDIR)$2),$(strip \
)cd '$(DESTDIR)$2' && rm -f$(if $3, $3) $1$(am.chars.newline)))
endef

define am.uninst.cmd
$(call am.xargs-map,$0.aux,$(strip $2),$(strip $1),$(strip $3))
endef
